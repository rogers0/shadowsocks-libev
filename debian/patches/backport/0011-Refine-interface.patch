From: Max Lv <max.c.lv@gmail.com>
Date: Mon, 27 Mar 2017 13:09:22 +0800
Subject: Refine interface

---
 src/local.c | 22 +++++++++-------------
 1 file changed, 9 insertions(+), 13 deletions(-)

diff --git a/src/local.c b/src/local.c
index b75f2c4..f3e2691 100644
--- a/src/local.c
+++ b/src/local.c
@@ -1723,20 +1723,20 @@ start_ss_local_server(profile_t profile)
     if (crypto == NULL)
         FATAL("failed to init ciphers");
 
-    struct sockaddr_storage *storage = ss_malloc(sizeof(struct sockaddr_storage));
-    memset(storage, 0, sizeof(struct sockaddr_storage));
-    if (get_sockaddr(remote_host, remote_port_str, storage, 0, ipv6first) == -1) {
+    struct sockaddr_storage storage;
+    memset(&storage, 0, sizeof(struct sockaddr_storage));
+    if (get_sockaddr(remote_host, remote_port_str, &storage, 0, ipv6first) == -1) {
         return -1;
     }
 
     // Setup proxy context
     struct ev_loop *loop = EV_DEFAULT;
 
-    struct sockaddr **remote_addr_tmp = ss_malloc(sizeof(struct sockaddr *));
+    struct sockaddr *remote_addr_tmp[MAX_REMOTE_NUM];
     listen_ctx_t listen_ctx;
     listen_ctx.remote_num     = 1;
     listen_ctx.remote_addr    = remote_addr_tmp;
-    listen_ctx.remote_addr[0] = (struct sockaddr *)storage;
+    listen_ctx.remote_addr[0] = (struct sockaddr *)(&storage);
     listen_ctx.timeout        = timeout;
     listen_ctx.iface          = NULL;
     listen_ctx.mptcp          = mptcp;
@@ -1764,7 +1764,7 @@ start_ss_local_server(profile_t profile)
     // Setup UDP
     if (mode != TCP_ONLY) {
         LOGI("udprelay enabled");
-        struct sockaddr *addr = (struct sockaddr *)storage;
+        struct sockaddr *addr = (struct sockaddr *)(&storage);
         init_udprelay(local_addr, local_port_str, addr,
                       get_sockaddr_len(addr), mtu, crypto, timeout, NULL);
     }
@@ -1785,20 +1785,16 @@ start_ss_local_server(profile_t profile)
     }
 
     // Clean up
-    if (mode != TCP_ONLY) {
-        free_udprelay();
-    }
-
     if (mode != UDP_ONLY) {
         ev_io_stop(loop, &listen_ctx.io);
         free_connections(loop);
         close(listen_ctx.fd);
     }
 
-    ss_free(listen_ctx.remote_addr[0]);
-    ss_free(remote_addr_tmp);
+    if (mode != TCP_ONLY) {
+        free_udprelay();
+    }
 
-    // cannot reach here
     return 0;
 }
 
